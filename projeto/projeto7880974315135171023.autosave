import peasy.*;


private final float UNIT = 9;
private final float BASE_RADIUS = 21 * UNIT;
private final float BASE_HEIGHT = 3 * UNIT;
private final float JOINT_OUTER_RADIUS = 3 * UNIT;
private final float JOINT_INNER_RADIUS = 2 * UNIT;
private final float JOINT_HEIGHT = 2.5 * UNIT;
private final float LOWER_LEG_RADIUS = 1.5 * UNIT;
private final float LOWER_LEG_HEIGHT = 10 * UNIT;
private final float UPPER_LEG_RADIUS = 1 * UNIT;
private final float LENGTH_INCREMENT = 0.5 * UNIT;
private final float POS_INCREMENT = 0.1 * UNIT;
private final float ANGLE_INCREMENT = PI / 360;


// Camera
PeasyCam cam;
int camMode = 1;

// Modo de controle
String mode = "passive";
int legSelect = 0;

// Posicao dos pistoes
float[] xLeg = new float[6];
float[] yLeg = new float[6];

// Comprimento e rotacao dos pistoes
float[] upperLegLengths = new float[6];
float[] upperLegIncrement = new float[6];
float[] azimuths = new float[6];
float[] azimuthIncrement = new float[6];
float[] elevations = new float[6];
float[] elevationIncrement = new float[6];

// Posicao e rotacao da plataforma
float[] platPos = new float[3];
float[] platPosIncrement = new float[3];
float[] platRot = new float[3];
float[] platRotIncrement = new float[3];

float elevacao = 30 * UNIT;
float deslocamento_y = 0;
float deslocamento_x = 0;
float yaw = 0;
float pitch = 0;
float roll = 0;

float del_elevacao;
float del_deslocamento_y;
float del_deslocamento_x;
float del_yaw;
float del_pitch;
float del_roll;

void setup() {
  xLeg[0] = 15 * UNIT;
  xLeg[1] = 15 * UNIT;
  xLeg[2] = - 15 * UNIT * sin(PI / 6) + 5 * UNIT * cos(PI / 6);
  xLeg[3] = - 15 * UNIT * sin(PI / 6) - 5 * UNIT * cos(PI / 6);
  xLeg[4] = - 15 * UNIT * sin(PI / 6) - 5 * UNIT * cos(PI / 6);
  xLeg[5] = - 15 * UNIT * sin(PI / 6) + 5 * UNIT * cos(PI / 6);

  yLeg[0] = 5 * UNIT;
  yLeg[1] = -5 * UNIT;
  yLeg[2] = - 15 * UNIT * cos(PI / 6) - 5 * UNIT * sin(PI / 6);
  yLeg[3] = - 15 * UNIT * cos(PI / 6) + 5 * UNIT * sin(PI / 6);
  yLeg[4] = 15 * UNIT * cos(PI / 6) - 5 * UNIT * sin(PI / 6);
  yLeg[5] = 15 * UNIT * cos(PI / 6) + 5 * UNIT * sin(PI / 6);

  upperLegLengths[0] = 5 * UNIT;
  upperLegLengths[1] = 5 * UNIT;
  upperLegLengths[2] = 5 * UNIT;
  upperLegLengths[3] = 5 * UNIT;
  upperLegLengths[4] = 5 * UNIT;
  upperLegLengths[5] = 5 * UNIT;

  azimuths[0] = 0;
  azimuths[1] = 0;
  azimuths[2] = 0;
  azimuths[3] = 0;
  azimuths[4] = 0;
  azimuths[5] = 0;

  elevations[0] = PI / 2;
  elevations[1] = PI / 2;
  elevations[2] = PI / 2;
  elevations[3] = PI / 2;
  elevations[4] = PI / 2;
  elevations[5] = PI / 2;

  platPos[2] = BASE_HEIGHT + JOINT_HEIGHT / 2 + LOWER_LEG_HEIGHT + upperLegLengths[0];

  fullScreen(P3D);

  cam = new PeasyCam(this, 100);
  cam.setMinimumDistance(50);
  cam.setMaximumDistance(500);
}

void draw() {
  background(0);

  translate(width/2, height/2);

  if (camMode == 0) {
    // Vista estatica
    camera(500, 0, 10 * UNIT, 0.0, 0.0, 0.0, 1, 0, 0);
  } else if (camMode == 1) {
    // Vista dinamica
    camera(60 * UNIT * cos(2 * PI * mouseX / width), 60 * UNIT * sin(2 * PI * mouseX / width - PI), 2.2 * height / 5 - mouseY / 2, 0.0, 0.0, 10 * UNIT, 0, 0, -1);
  }

  cam.beginHUD();
  fill(-1);
  String hudPlatPos = String.format("Platform Position: [%.2f, %.2f, %.2f]", platPos[0], platPos[1], platPos[2]);
  text(hudPlatPos, width * .05, height * .875);
  String hudPlatRot =  String.format("Platform Rotation: [%.2f, %.2f, %.2f]", platRot[0], platRot[1], platRot[2]);
  text(hudPlatRot, width * .05, height * .9);

  for (int i = 0; i < 6; i++) {
    String hudLeg = String.format("Piston %d:\n\tLength: %.2f, Azimuth: %.2f, Elevation: %.2f", i + 1, upperLegLengths[i], azimuths[i], elevations[i]);
    text(hudLeg, width * .8, height * .04 * (i + 1));
  }
  String hudCam = "Cam Mode: ";
  if (camMode == 0) {
    fill(255, 0, 0);
    hudCam += "Static";
  } else
    hudCam += "Dynamic";
  text(hudCam, width * .05, height * .04);
  cam.endHUD();

  lights();
  fill(255);
  stroke(155);


  // Desenha base
  drawCylinder(BASE_RADIUS, BASE_HEIGHT);

  // Desenha ligacoes inferiores
  for (int i = 0; i < 6; i++) {
    pushMatrix();
    translate(xLeg[i], yLeg[i], 3 * UNIT);
    drawCylinder(JOINT_OUTER_RADIUS, JOINT_HEIGHT);
    translate(0, 0, 2 * UNIT);
    noStroke();
    sphere(JOINT_INNER_RADIUS);
    stroke(155);
    popMatrix();
  }

  // Movimenta plataforma
  elevacao = elevacao + del_elevacao;
  deslocamento_y = deslocamento_y + del_deslocamento_y;
  deslocamento_x = deslocamento_x + del_deslocamento_x;
  yaw = yaw + del_yaw;
  pitch = pitch + del_pitch;
  roll = roll + del_roll;
  pushMatrix();
  translate(deslocamento_x, deslocamento_y, elevacao);
  rotateX(roll);
  rotateY(pitch);
  rotateZ(yaw);

  // Desenha plataforma
  drawCylinder(BASE_RADIUS, BASE_HEIGHT);

  // Desenha ligacoes superiores
  rotateZ(PI / 3);
  for (int i = 0; i < 6; i++) {
    pushMatrix();
    translate(xLeg[i], yLeg[i], - 2 * UNIT);
    drawCylinder(JOINT_OUTER_RADIUS, JOINT_HEIGHT);
    noStroke();
    sphere(JOINT_INNER_RADIUS);
    stroke(155);
    popMatrix();
  }
  popMatrix();

  pistao();
}


// Atualiza parametros 
void updateParams(float[] x, float[] y) {
  platPos[0] += platPosIncrement[0];
  platPos[1] += platPosIncrement[1];
  platPos[2] += platPosIncrement[2];

  platRot[0] += platRotIncrement[0];
  platRot[1] += platRotIncrement[1];
  platRot[2] += platRotIncrement[2];

  // TODO: otimizar codigo
  for (int i = 0; i < 6; i++) {
    PVector p = new PVector(x[i], y[i], 0);
    p = rotate3D(p, platRot[0], 0);
    p = rotate3D(p, platRot[1], 1);
    p = rotate3D(p, platRot[2], 2);
    PVector trans = new PVector(platPos[0], platPos[1], platPos[2]);
    PVector q = p.add(trans);
    PVector b = new PVector(x[i], y[i], 0);
    PVector l = q.sub(b);

    upperLegLengths[i] = l.mag() - LOWER_LEG_HEIGHT - BASE_HEIGHT - JOINT_HEIGHT / 2;  // TODO: checar negativo
    float[] qArr = q.normalize().array();
    azimuths[i] = PI - atan2(qArr[0], qArr[1]);
    elevations[i] = atan2(qArr[2], sqrt(pow(qArr[0], 2) + pow(qArr[1], 2)));
  }
}

PVector rotate3D(PVector vector, float angle, int axis) {
  PVector ret = vector.copy();
  float[] pos = vector.array();
  PVector vector2D;

  if (axis == 0) {
    vector2D = new PVector(pos[1], pos[2]);
    vector2D.rotate(angle);
    float[] newPos = vector2D.array();
    ret = new PVector(pos[0], newPos[0], newPos[1]);
  } else if (axis == 1) {
    vector2D = new PVector(pos[2], pos[0]);
    vector2D.rotate(angle);
    float[] newPos = vector2D.array();
    ret = new PVector(newPos[1], pos[1], newPos[0]);
  } else if (axis == 2) {
    vector2D = new PVector(pos[0], pos[1]);
    vector2D.rotate(angle);
    float[] newPos = vector2D.array();
    ret = new PVector(newPos[0], newPos[1], pos[2]);
  }

  return ret;
}

void drawLegs(float[] x, float[] y) {
  for (int i = 0; i < 6; i++) {
    drawLeg(upperLegLengths[i], x[i], y[i], azimuths[i], elevations[i]);
  }
}

void drawLeg(float upperLegLength, float x, float y, float azimuth, float elevation) {
  pushMatrix();
  translate(x, y, BASE_HEIGHT + JOINT_INNER_RADIUS);
  rotateZ(azimuth);
  rotateX(PI / 2 - elevation);
  drawCylinder(LOWER_LEG_RADIUS, LOWER_LEG_HEIGHT);
  translate(0, 0, LOWER_LEG_HEIGHT);
  drawCylinder(UPPER_LEG_RADIUS, upperLegLength);
  popMatrix();
}

void drawPlatform() {
  pushMatrix();
  rotateX(platRot[0]);
  rotateY(platRot[1]);
  rotateZ(platRot[2]);
  translate(platPos[0], platPos[1], platPos[2]);
  drawCylinder(BASE_RADIUS, BASE_HEIGHT);
  for (int i = 0; i < 6; i++) {
    pushMatrix();
    translate(xLeg[i], yLeg[i], - 2 * UNIT);
    drawCylinder(JOINT_OUTER_RADIUS, JOINT_HEIGHT);
    //translate(0, 0, - 2 * UNIT);
    noStroke();
    sphere(JOINT_INNER_RADIUS);
    stroke(155);
    popMatrix();
  }
  popMatrix();
}

void pistao() {
  // bottom
  pushMatrix();
  translate(xLeg[0], yLeg[0], 3 * UNIT);
  beginShape();
  for (int i = 0; i < 360; i ++) {
    float x = cos( radians(i)) * JOINT_INNER_RADIUS;
    float y = sin( radians(i)) * JOINT_INNER_RADIUS;
    vertex( x, y, 0);
  }
  endShape(CLOSE);
  popMatrix();
  // top
  pushMatrix();
  translate(deslocamento_x, deslocamento_y, elevacao);
  rotateX(roll);
  rotateY(pitch);
  rotateZ(yaw);
  rotateZ(PI / 3);
  translate(xLeg[1], yLeg[1], -2 * UNIT);
  beginShape();
  for (int i = 0; i < 360; i ++) {
    float x = cos( radians(i)) * JOINT_INNER_RADIUS;
    float y = sin( radians(i)) * JOINT_INNER_RADIUS;
    vertex( x, y, 0);
  }
  endShape(CLOSE);
  popMatrix();
  pushMatrix();
  // draw body
  noStroke();
  beginShape(TRIANGLE_STRIP);
  for (int i = 0; i < 360; i++) {
    float x_i = xLeg[0];
    float y_i = yLeg[0];
    float z_i = 5 * UNIT;
  }
  endShape(CLOSE);
  stroke(155);
  popMatrix();
}

void drawCylinder(float r, float h)
{
  int sides = 360;
  float angle = 1;
  // bottom
  beginShape();
  for (int i = 0; i < sides; i++) {
    float x = cos( radians( i * angle ) ) * r;
    float y = sin( radians( i * angle ) ) * r;
    vertex( x, y, 0);
  }
  endShape(CLOSE);
  // top
  beginShape();
  for (int i = 0; i < sides; i++) {
    float x = cos( radians( i * angle ) ) * r;
    float y = sin( radians( i * angle ) ) * r;
    vertex( x, y, h);
  }
  endShape(CLOSE);
  // draw body
  noStroke();
  beginShape(TRIANGLE_STRIP);
  for (int i = 0; i < sides + 1; i++) {
    float x = cos( radians( i * angle ) ) * r;
    float y = sin( radians( i * angle ) ) * r;
    vertex( x, y, 0);
    vertex( x, y, h);
  }
  endShape(CLOSE);
  stroke(155);
}

void keyPressed() {

  // ajuste da cÃ¢mera
  if (key == 'c') {
    if (camMode  >= 1)
      camMode = 0;
    else
      camMode++;
  }

  // modo de funcionamento da plataforma
  if (key == 'w')
    del_elevacao = POS_INCREMENT;
  if (key == 's')
    del_elevacao = -POS_INCREMENT;
  if (key == 'a') del_deslocamento_x = -POS_INCREMENT;
  if (key == 'd') del_deslocamento_x = POS_INCREMENT;
  if (key == 'q') del_deslocamento_y = -POS_INCREMENT;
  if (key == 'e') del_deslocamento_y = POS_INCREMENT;

  if (key == '1') del_yaw = -ANGLE_INCREMENT;
  if (key == '2') del_yaw = ANGLE_INCREMENT;
  if (key == '3') del_pitch = -ANGLE_INCREMENT;
  if (key == '4') del_pitch = ANGLE_INCREMENT;
  if (key == '5') del_roll = -ANGLE_INCREMENT;
  if (key == '6') del_roll = ANGLE_INCREMENT;
}

void keyReleased() {
  if (key == 'w' || key == 's') del_elevacao = 0;
  if (key == 'a' || key == 'd') del_deslocamento_x = 0;
  if (key == 'q' || key == 'e') del_deslocamento_y = 0;
  if (key == '1' || key == '2') del_yaw = 0;
  if (key == '3' || key == '4') del_pitch = 0;
  if (key == '5' || key == '6') del_roll = 0;
}
